* DONE connections.cc:127:  cgs = new conn_global_state(evbase);
* DONE crypt.cc:187:  ecb_encryptor_impl *enc = new ecb_encryptor_impl;
* DONE crypt.cc:205:  ecb_encryptor_impl *enc = new ecb_encryptor_impl;
* DONE crypt.cc:225:  ecb_decryptor_impl *dec = new ecb_decryptor_impl;
* DONE crypt.cc:243:  ecb_decryptor_impl *dec = new ecb_decryptor_impl;
* DONE crypt.cc:358:  gcm_encryptor_impl *enc = new gcm_encryptor_impl;
* DONE crypt.cc:374:  gcm_encryptor_impl *enc = new gcm_encryptor_impl;
* DONE crypt.cc:392:  gcm_decryptor_impl *dec = new gcm_decryptor_impl;
* DONE crypt.cc:408:  gcm_decryptor_impl *dec = new gcm_decryptor_impl;
* DONE crypt.cc:592:  ecdh_message_impl *imp = new ecdh_message_impl(secret);
* TODO evbuf_util.cc:28:  assert(*memory_block = new uint8_t[sbuflen]); 
* DONE protocol/chop.cc:307:      transparent_proxy = new TransparentProxy(base, options[2]);
* DONE protocol/chop.cc:450:  chop_circuit_t *ckt = new chop_circuit_t(retransmit);
* DONE protocol/chop.cc:1598:  chop_conn_t *conn = new chop_conn_t;
* DONE protocol/chop.cc:1773:  originally_received = new uint8_t[received_length];
* DONE protocol/null.cc:126:  null_circuit_t *ckt = new null_circuit_t;
* DONE protocol/null.cc:224:  null_conn_t *conn = new null_conn_t;
* DONE protocol.h:115:  { mod##_config_t *s = new mod##_config_t();                   \
* DONE steg/http.cc:51:    payload_server = new TracePayloadServer(is_clientside ? client_side : server_side, payload_filename);
* DONE steg/http.cc:65:  file_steg_mods[HTTP_CONTENT_JPEG] = new JPGSteg(payload_server, noise2signal);
* DONE steg/http.cc:66:  file_steg_mods[HTTP_CONTENT_PNG] = new PNGSteg(payload_server, noise2signal);
* DONE steg/http.cc:67:  file_steg_mods[HTTP_CONTENT_GIF] = new GIFSteg(payload_server, noise2signal);
* DONE steg/http_steg_mods/file_steg.cc:296:  outbuf = new uint8_t[c_HTTP_MSG_BUF_SIZE];
* DONE steg/http_steg_mods/jsSteg.cc:928:  char* buf2print = new char[s2.pos+2];
* DONE steg/payload_scraper.cc:195:  _available_stegs = new steg_type[c_no_of_steg_protocol];
* DONE steg/payload_scraper.cc:212:  _available_file_stegs[HTTP_CONTENT_JPEG] = new JPGSteg(NULL); //We are only using the capacity function so we don't need a payload server
* DONE steg/payload_scraper.cc:215:  _available_file_stegs[HTTP_CONTENT_PNG] = new PNGSteg(NULL); //We are only using the capacity function so we don't need a payload server
* DONE steg/payload_scraper.cc:218:  _available_file_stegs[HTTP_CONTENT_GIF] = new GIFSteg(NULL); //We are only using the capacity function so we don't need a payload server
* DONE steg/payload_scraper.cc:396:  char* buf = new char[apache_size]; log_assert(buf);
* DONE steg/http_apache.cc:190:  payload_server = new ApachePayloadServer(is_clientside ? client_side : server_side, payload_filename, cover_server, cover_list);
* DONE steg/http_apache.cc:783:          char* dict_buf = new char[dict_buf_size];
test/webpage_tester.cc:180:    _parser = new http_parser;
test/webpage_tester.cc:418:      char* debug_buf = new char[buffer_size+1];
test/tester_proxy/tester_proxy.cc:134:          char* debug_buf = new char[buffer_size+1];
test/steg_test/steg_mod_unittest.cc:65:   cover_payload = new uint8_t[cover_len];
test/steg_test/steg_mod_unittest.cc:105:    short_message = new char[strlen(local_short)+1];
test/steg_test/steg_mod_unittest.cc:106:    long_message = new char[strlen(local_long)+1];
test/steg_test/pngSteg_unittest.cc:72:   cover_payload = new uint8_t[cover_len];
test/steg_test/stegMod_unittest.cc:72:   cover_payload = new uint8_t[cover_len];
test/tltester.cc:218:      char* debug_buf = new char[buffer_size+1];
test/gtest/src/gtest-filepath.cc:357:  char* const dest = new char[pathname_.length() + 1];
test/gtest/src/gtest-death-test.cc:1182:    *test = new WindowsDeathTest(statement, regex, file, line);
test/gtest/src/gtest-death-test.cc:1188:    *test = new ExecDeathTest(statement, regex, file, line);
test/gtest/src/gtest-death-test.cc:1190:    *test = new NoExecDeathTest(statement, regex);
test/gtest/src/gtest-port.cc:176:  char* const full_pattern = new char[full_regex_len];
test/gtest/src/gtest-port.cc:607:  char* const buffer = new char[file_size];
test/gtest/src/gtest-port.cc:640:  *stream = new CapturedStream(fd);
test/gtest/src/gtest.cc:846:  WCHAR* unicode = new WCHAR[unicode_length + 1];
test/gtest/src/gtest.cc:862:  char* ansi = new char[ansi_length + 1];
test/gtest/src/gtest.cc:3654:  static UnitTest* const instance = new UnitTest;
test/gtest/src/gtest.cc:3969:  impl_ = new internal::UnitTestImpl(this);
test/gtest/src/gtest.cc:4586:    os_stack_trace_getter_ = new OsStackTraceGetter;
test/gtest/include/gtest/internal/gtest-internal.h:1006:      Element* const copy = new Element[a_size];
test/gtest/include/gtest/internal/gtest-port.h:1523:    ValueHolder* const new_holder = new ValueHolder(default_);
test/gtest/include/gtest/internal/gtest-param-util.h:594:      typed_test_info = new ParameterizedTestCaseInfo<TestCase>(test_case_name);
test/webpage_tester.cc.orig:195:    _parser = new http_parser;
test/webpage_tester.cc.orig:433:      char* debug_buf = new char[buffer_size+1];
transparent_proxy.cc:174:          char* debug_buf = new char[buffer_size+1];
